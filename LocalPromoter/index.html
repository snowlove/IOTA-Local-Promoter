<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>IOTA local PoW Promotion / Reattachment tool</title>
		
		<script type="text/javascript" src="libs/iota.min.js"></script>
		<script type="text/javascript" src="libs/curl.min.js"></script>
		<script type="text/javascript" src="libs/iota.extensions.js"></script>

<script>
	var iota, node, logElement;

	var user = {
		nodes : '',
		hashes : {length : 0}, //structure { hash : { hashes : {}, current : bool, confirmed : bool } }
		hashindex : 0,
		weight : 14,
		promo : 0,
		promoMax : 55,
		params : { interrupt : function() { if(user.promo > 0) { print(user.promo.toString() + "/" + user.promoMax.toString() + " promotions :: " + Object.keys(user.hashes)[user.hashindex]); } if(user.interrupt) return true; else return user.promo++ >= user.promoMax; }, delay: 200 },
		interrupt : false,
		inclusionworker : false
	}
	/*
	* Partial by   : snowlove
	* website      :  https://cindar.me
	* LICENSE    : Creative Commons [BY][SA][NC] : https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode.txt
	*/

	function timestamp() {
		var date = new Date();
		var hh = date.getHours() < 10 ? "0" + date.getHours() : date.getHours();
		var mm = date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes();
		var ss = date.getSeconds() < 10 ? "0" + date.getSeconds() : date.getSeconds();
		time = hh + ":" + mm + ":" + ss;
		
		return time;
	}


	function print(msg, e=false, type=null) {
		if(e) Toggle_Submit();
		var tmp;
		var logline = document.createElement("div");
		tmp = "[" + timestamp() + "]: ";
		if(type == 1) { //warning
			tmp += '<span class="badge badge-warning">Warning</span> ';
		} else if(type == 2) { //success
			tmp += '<span class="badge badge-success">Success</span> ';
		} else if (type == 3) { //danger
			tmp += '<span class="badge badge-danger">Error</span> ';
		} else if (type == 4) { //info
			tmp += '<span class="badge badge-info">Info</span> ';
		} else if (type == 5) { //'primary' the orange one
			tmp += '<span class="badge badge-primary">' + 'amsg' + '</span> ';
		}
		
		tmp += msg;
		
		logline.innerHTML = tmp;
		logElement.insertBefore(logline, logElement.firstChild);
	}


	function changefield(field) {
		if (field == "hash") {
			var c = document.getElementById("TransactionHash");
			var tmp = "";
			
			/*for(var i=0, len = Object.keys(user.hashes).length; i < len; i++) {
				i+1 == len ? tmp = tmp + Object.keys(user.hashes)[i] : tmp = tmp + Object.keys(user.hashes)[i] + ",";
			}*/
			for(var i=0, len = user.hashes.length; i <= len; i++) {
				if(Object.keys(user.hashes)[i] != "length" && user.hashes[Object.keys(user.hashes)[i]].confirmed == false) i == len ? tmp = tmp + Object.keys(user.hashes)[i] : tmp = tmp + Object.keys(user.hashes)[i] + ",";
			}
			c.value = tmp;
		}
	}

	
	/* validatefield(value, sender) */
	/* returns bool */
	function validatefield(v, s) {
		if(s == 'hash') {
			if(!v || !iota.valid.isHash(v)) {
				print("Invalid hash detected :: " + v.toString(), true, 3);
				return false;
			} else {
				return true;
			}
		}
		
		if(s == 'node') {
			var gruber = /\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i;
			if(!v || !gruber.exec(v)) {
				print("Invalid node", true, 3);
				return false;
			} else {
				return true;
			}
		}
	}
	
	
	/* Check for webgl support because it's required. */
	function webgl_support() {
		try{ var canvas = document.createElement( 'canvas' ); return !! window.WebGLRenderingContext && (canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ); }catch( e ) { return false; }
	}
	
	
	function pageLoaded() {
		if(!iota) iota = new IOTA();
		iota.api.attachToTangle = iota.localAttachToTangle;
		iota.api.__proto__.attachToTangle = iota.localAttachToTangle;
		iota.api.interruptAttachingToTangle = iota.localInterruptAttachingToTangle;
		iota.api.__proto__.interruptAttachingToTangle = iota.localInterruptAttachingToTangle;
		logElement = document.getElementById("eventLogContent");
		print("Testing for WebGL...");
		
		if(webgl_support())
			print("WebGL enabled READY, SET, GO!",false,2);
		else
			print("WebGL not enabled. [<a href=\"https://www.google.com/search?q=How+do+I+enable+WebGL&ie=utf-8\">Click here</a>] for help enabling it.", true, 3);	
	}

	
	/*function removeduplicates(arr) {
		let unique_array = arr.filter(function(elem, index, self) {
			return index == self.indexOf(elem);
		});
		return unique_array
	}*/


	function inclusionWorker() { //this should be the only function to remove a hash, outside of invalid hash during validation.
		//if(Object.keys(user.hashes).length < 1) return;

		print("[InclusionWorker] initializing", false, 4);
		var bht = [];
		for (var i=0, len = user.hashes.length; i<=len; i++) if(Object.keys(user.hashes)[i] != "length") bht = bht.concat(user.hashes[Object.keys(user.hashes)[i]].bundle);
		
		function checkbundles(e, s) {
			if(e) { console.log(err); return; }
			print("[InclusionWorker] checking confirmation states..", false, 4);
			
			var bundles = [];
			var conf = 0;
			
			for(var i=1, len = user.hashes.length; i<=len; i++) {
				if(s[i]) conf++;
				if(s[i] && user.hashes[Object.keys(user.hashes)[i]].confirmed == false) {
					user.hashes[Object.keys(user.hashes)[i]].confirmed = true;
					if(Object.keys(user.hashes)[i] == Object.keys(user.hashes)[user.hashindex]) user.interrupt = true;
					print("[InclusionWorker] " + Object.keys(user.hashes)[i] + " confirmed", false, 2);
				}
			}

			for (var i=0, len = user.hashes.length; i<=len; i++) if(Object.keys(user.hashes)[i] != "length") bundles = bundles.concat(user.hashes[Object.keys(user.hashes)[i]].bundle);

			if(conf < user.hashes.length) {
				setTimeout(function () { iota.api.getLatestInclusion(bundles, checkbundles) }, 10000);
			} else {
				print("[InclusionWorker] shutting down :: all hashes confirmed", false, 2);
				user.inclusionworker = false;
			}
		}
		
		/* function checkbundles(err, isinc) {
			if(err) { console.log(err); return; }
			print("[InclusionWorker] checking confirmation states..", false, 4);
			var bundlehashes = [];
			var c = 0;
			
			for (var key in user.hashes) {
				bundlehashes = bundlehashes.concat(user.hashes[key]);
			}
			
			isinc.forEach(function(v) {
				if(v) {
					for (var key in user.hashes) {
						if(Object.keys(user.hashes)[0] == bundlehashes[c]) user.interrupt = true; //interrupting if current
						
						if(user.hashes[key].includes(bundlehashes[c])) {
							print("[InclusionWorker] " + key + " confirmed", false, 2);
							delete user.hashes[key]; //bye bye
						}
					}
				} c++;
			});
			
			if(Object.keys(user.hashes).length > 0) {
				setTimeout(function () { iota.api.getLatestInclusion(bundlehashes, checkbundles) }, 10000);
			} else {
				print("[InclusionWorker] shutting down :: all hashes confirmed", false, 2);
				user.inclusionworker = false;
			}
		} */
		iota.api.getLatestInclusion(bht, checkbundles);
	}

	
	function Toggle_Submit() {
		if(document.getElementById("promote-submit").disabled == true)
		{
			document.getElementById("promote-submit").disabled = false;
			document.getElementById("reattach-submit").disabled = false;
		} else {
			document.getElementById("promote-submit").disabled = true;
			document.getElementById("reattach-submit").disabled = true;
		}
	}


	/*****************
	*	testing area
	*	-
	*	var x = utils.isBundle(); api.isPromotable() true / false
	*****************/
	function TestFunction(hash, node) {
		print("This is a button I use for testing new features :)");
		iota._makeRequest.provider = node;
	}
	

	/***************************************
	*			function attribution by:
	*						Orth
	*			Modified by Snowlove
	*	To find the latest attachment tail
	****************************************/
	function get_tail_tx(hash) {
		return new Promise(function(resolve, reject) {
			function txtxtx(hash) {
				iota.api.findTransactionObjects({bundles: [hash]}, (err, bundle) => {
					if (err || bundle.length == 0) {
						iota.api.getTransactionsObjects([hash], (err, tx) => {
							if (err || hash == "999999999999999999999999999999999999999999999999999999999999999999999999999999999") { reject("unable to locate tail :: transaction may be too old"); return; }
							txtxtx(tx[0].bundle);
						});
					} else {
						var tmpObj = [];
						var incBundle = [];
				
						bundle.forEach(function(v) {
							if(v.currentIndex == 0) {
								incBundle.push(v.hash);
								
								if(typeof tmpObj[0] == 'undefined')
									tmpObj.push(v)
								else
									if(v.attachmentTimestamp > tmpObj[0].attachmentTimestamp) { tmpObj.pop(); tmpObj.push(v); }
							}
						});
						
						if (typeof user.hashes[tmpObj[0].hash] == 'undefined') { //only input values into the object if undefined. because, bbq, also duplicates.
							user.hashes[tmpObj[0].hash] = { bundle : incBundle, confirmed : false, index : user.hashes.length }
							user.hashes.length++;
						}
						//user.hashes[tmpObj[0].hash] = incBundle;
						resolve(tmpObj[0].hash);
					}
				});
			} txtxtx(hash);
		});
	}


	function Worker_DoWork(sender) {
		//delete user.hashes[Object.keys(user.hashes)[0]];
		user.hashindex++;
		if(user.hashindex < user.hashes.length) {
			if(sender == "promote") {
				print("promoting hash: " + Object.keys(user.hashes)[user.hashindex], false, 4);
				user.promo = 0;
				user.interrupt = false;
				Promote_Transaction(Object.keys(user.hashes)[user.hashindex]);
			} else if(sender == "attach") {
				print("reattaching hash: " + Object.keys(user.hashes)[user.hashindex], false, 4);
				reattachTransaction(Object.keys(user.hashes)[user.hashindex]);
			}
		} else {
			if(sender == "promote")
				print("all promotions finished", true, 2);
			else if (sender =="attach")
				print("all reattachments finished", true, 2);
			else
				print("unknown error", true, 3);

			changefield('hash');
		}
		
		/*if(Object.keys(user.hashes).length > 0) {
			if(sender == "promote") {
				print("promoting hash: " + Object.keys(user.hashes)[0], false, 4);
				user.promo = 0;
				user.interrupt = false;
				Promote_Transaction(Object.keys(user.hashes)[0]);
			} else if(sender == "attach") {
				print("reattaching hash: " + Object.keys(user.hashes)[0], false, 4);
				reattachTransaction(Object.keys(user.hashes)[0]);
			}
		} else {
			if(sender == "promote")
				print("all promotions finished", true, 2);
			else if (sender =="attach")
				print("all reattachments finished", true, 2);
			else
				print("unknown error", true, 3);
				
			changefield('hash');
		}*/
	}

	
	async function preprocesstx(inputs) {
		return new Promise(async function(resolve, reject) {
			for(var i=0, len = inputs.length; i < len; i++) {
				var x;
				if(!validatefield(inputs[i], 'hash')) reject("invalid hash");

				try { x = await get_tail_tx(inputs[i]); } catch(e) { reject(e); return; }
				
				if(x != inputs[i]) {
					print("processing " + (i+1) + "/" + len.toString() + "\n" + inputs[i] + " => " + x, false, 4);
				} else {
					print("processing " + (i+1) + "/" + len.toString() + "\n" + inputs[i] + " => GOOD", false, 4);
				}
			}

			changefield('hash');
			resolve("done processing transactions");
		});
	}
	
	
	async function preflight(hash, node, btn) {
		print("Starting...", true, 4);
		if(!validatefield(node, 'node')) return; else iota._makeRequest.provider = node;
		
		if(hash.match(/(?:\r\n|\r|\n|\s)/g))
			hash = hash.replace(/(?:\r\n|\r|\n|\s)/g, '');
			
		hash = hash.split(',');

		try {
			var x = await preprocesstx(hash);
			print(x, false, 2);
		} catch(e) {
			if(!e.toString().includes("invalid hash"))
				print(e, true, 3);
				
			return;
		}


		user.interrupt = false;
		user.promo = 0;
		user.hashindex = 1; //skip length
		
		if(!user.inclusionworker) {
			inclusionWorker();
			user.inclusionworker = true;
		}
		
		if (btn == "promote") {
			iota.api.getLatestInclusion([Object.keys(user.hashes)[user.hashindex]], function(e, s) {
				if(e) { print("Error during pre-flight inclusion detection. => " + e.toString(), true, 3); return false; }
				if(!s[0]) Promote_Transaction(Object.keys(user.hashes)[user.hashindex]);
				else { print("skipping :: " + Object.keys(user.hashes)[user.hashindex] + " already confirmed", false, 2); Worker_DoWork("promote"); }
			});
		} else if (btn == "reattach") {
			reattachTransaction(Object.keys(user.hashes)[user.hashindex]);
		} else {
			print("stop breaking things.", true, 2);
		}
	}


	function reattachTransaction(hash) {
		print("starting reattachment", false, 4);
		print(hash, false, 4);
		iota.api.replayBundle(hash, 3, 14, function(e, s) {
			if(s) {
				for(var key in user.hashes) {
					if (key == hash) {
						user.hashes[key]['bundle'].push(key); //push
						user.hashes[s[0].hash] = user.hashes[key]; //switch
						delete user.hashes[key]; //pop
					}
				}
				
				print("reattached sucessful :: " + s[0].hash, false, 2);
			}
			
			if(e) {
				if (e.toString().includes("tail")) {
					print("skipping :: hash is not the transaction tail", false, 1);
					//get_tail_tx(hash);
				} else { print(e, false, 3); }
			}
			
			Worker_DoWork("attach");
		});
	}

	
	function Promote_Transaction(hash) {
		print("starting promotion", false, 4);
		const transfer = [{
			address: "IS9SOMEONE9GETTING9THE9BEST9THE9BEST9THE9BEST9THE9BEST9OF9YOU9SNOWLOVE99999999999",
			value: 0,
			message: "BCBDCDKD9DCDJDTCEASCCDBDTCEAKDTCBDHDEAPCBDSCEAIDGDTCSCEATBPCJDPCGDRCFDXCDDHDEAKDWCCDEAKDCDID9DSCEACDUCEAHDWCIDBDZCEAXCHDSAEAFDTCSCSCXCHDSARCCDADTAFDTAXCCDHDPCGDIDDDDDCDFDHD",
			tag: "999SNOWLOVE"
		}];

		iota.api.promoteTransaction(hash, 4, 15, transfer, user.params, function(e, s) {
			if (s) Worker_DoWork("promote");
			
			if(e) {
				if(e.toString().includes("Inconsistent")) {
					if(typeof Object.keys(user.hashes)[user.hashindex] !== "undefined") print("skipping :: Inconsistent subtangle => " + Object.keys(user.hashes)[user.hashindex], false, 1);
				} else if (e.toString().includes("tail")) {
					print("skipping :: hash is not the transaction tail", false, 1);
					//get_tail_tx(user.hashes[user.hashIndex], 1);
				} else if (e.toString().includes("Invalid transaction")) {
					print("skipping :: Invalid Transaction => " + Object.keys(user.hashes)[user.hashindex], false, 3);
				} else if (e.toString().includes('tip') || e.toString().includes("unlock read")) {
					print("hiccup starting promotion again.", false, 1);
					user.promo = 0;
					user.interrupt = false
					Promote_Transaction(Object.keys(user.hashes)[user.hashindex]);
					return;
				} else if (e.toString().includes("too old")) {
					print("skipping :: transaction is too old => " + Object.keys(user.hashes)[user.hashindex], false, 1)
				} else {
					if(typeof Object.keys(user.hashes)[user.hashindex] !== "undefined") {
						console.log(e);
						print("skipping :: unknown error :: => " + Object.keys(user.hashes)[user.hashindex], false, 3);
					}
				}
				Worker_DoWork("promote");
			}
		});
	}
	
window.onload = pageLoaded;
</script>

<link href="https://maxcdn.bootstrapcdn.com/bootswatch/4.0.0-beta.3/superhero/bootstrap.min.css" rel="stylesheet" integrity="sha384-5wAMKUlGYMj+I1P0kUCCwryZKMvv4S6K2e0UlixY5YK3Z4/HWKP9MtELCm0Iyo74" crossorigin="anonymous">
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous" />
<style type="text/css">
html, body { margin: 0;padding: 0;height: calc(100% - 60px);position: relative;width: 100%; }
.incwrap { margin: auto;width: 80%;padding-bottom: 100px; }

.navbar { min-height:  55px; margin-bottom: 20px; }
main { min-width: 900px;min-height: 100%; }
.form-control.number { width: auto; }
.form-control[type="color"] { width : 60px; padding : 2px; display : inline-block; }
.form-control[multiple] { height : auto; }
.form-control { width: 75%; display: inline-block; margin-top: 5px; }
label { padding-right: 5px; display: inline-block; width: 55px; font-weight: bold; } 

.border-light { color: white; }
pre > div > a { color: #E49647; }
pre > div > a:hover { color:#FFF; text-decoration:none; }
.badge { min-width:45px; }
footer { line-height: 45px; top: 0; position: relative; width: 100%; background-color:#4e5d6c; color: #FFF; overflow:auto; text-align:center; }
.fsStoreF { font-size: 1.2em; }
.fb-button.form-group.field-promote-submit { padding-left: 55px; }
.btn { width: 200px; }
.btn-addition { margin-left: 10px; }
.hidden { display: none; }
.provider { position: absolute; padding-right: 15px; right: 0px; } /* at Ralfs request, added link to the main iota.fm site since he's so kind to let us use his nodes as default. */
</style>

</head>

<body>
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
	<a class="navbar-brand" href="#">Local PoW</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation" style="">
		<span class="navbar-toggler-icon"></span>
	</button>
	
	<div class="collapse navbar-collapse" id="navbarColor02">
		<ul class="navbar-nav mr-auto">
		<li class="nav-item active">
			<a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
		</li>
		<li class="nav-item">
			<a class="nav-link" href="https://github.com/snowlove/IOTA-Local-Promoter">Project Github</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" href="https://discord.gg/fNGZXvh">IOTA Official Discord</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" href="https://www.reddit.com/r/IOTASupport/">IOTA Support subreddit</a>
		</li>
		</ul>
	</div>
	</nav>
	
	
	
	<main>
		<div class="incwrap">
		<form id="rendered-form">
			<div class="fb-text form-group field-promote-tx-hash-field">
				<label for="TransactionHash" style="vertical-align:top">Hash </label><textarea class="form-control" placeholder="Input a single hash or a list of hashes seperated by a comma. e.g. hash1,hash2,hash3,hash4" name="TransactionHash" id="TransactionHash" rows="2"></textarea><br />
				<label for="node">Node </label><input type="text" placeholder="http://iota.nodeaddress.com:9999" value="http://nodes.iota.fm:80" class="form-control" name="node" id="node" />
			</div>
			<div class="fb-button form-group field-promote-submit">
				<button type="button" class="btn btn-primary" name="promote-submit" style="default" id="promote-submit" onClick="preflight(TransactionHash.value, node.value, 'promote');">Promote</button>
				<button type="button" class="btn btn-primary btn-addition" name="reattach-submit" style="default" id="reattach-submit" onClick="preflight(TransactionHash.value, node.value, 'reattach');">Reattach</button>
				<button type="button" class="btn btn-primary btn-addition hidden" name="reattach-submit" style="default" id="reattach-submit" onClick="TestFunction(TransactionHash.value, node.value);">Test Function</button>
			</div>
		</form>
		
		<pre class="panel-body text-left card border-light mb-3" style="height:400px; overflow:auto; padding:5px;" id="eventLogContent"></pre>

		<p>Did this tool help you? Please donate to help create more tools like this: <span class="badge badge-light">OJVPGSRTVELYUW9IHEEBNJQCQXPMXNKFVTWW9ADLYYPDGXWQRACPGQSZCOHUVQSGWKMBNIZNXVYWULCUWDQLIGPALD</span></p>
		</div>
	</main>
	<footer class="fsStoref">
		<span class="ftext">By Snowlove - Rajiv (Original idea) - GpanosXP (Local PoW)</span><span class="provider">Default node provided by <a href="http://iota.fm">iota.fm</a></span>
	</footer>
</body>
</html>